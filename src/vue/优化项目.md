# 项目可优化的点有哪些

### 1、前端工程化中的大包压缩，减少文件的体积和数量，并且可通过文件的缓存管理，来达到更快的加载速度
  
  - 文件体积里面，可以做的优化有图片格式的选择和压缩
  - 静态资源可以通过CDN进行加载，有助于提高加载速度
  - 可以使用懒加载的思想减少首屏加载的文件数量

### 2、页面加载优化
  页面优化主要的方面有以下几个方面： css js html 图片
  - 页面渲染流程如下：
    处理html并且构建DOM 树
    处理 css构建CSSOM树
    DOM树和CSSOM树合成渲染树Render tree
    根据渲染树来进行布局，计算每一个节点的位置
    调用CPU进行绘制合成图层显示在屏幕上
    
在以上流程中可优化的点：
> css
1. 避免css堵塞：尽量将css文件放在head标签中，尽早加载css文件
2. 降低css选择器的复杂度，最好是控制在3层以内，防止过度嵌套
3. 避免使用通配符
4. 避免使用css表达式，因为它会被频繁的计算

> js
1. 避免js阻塞，js会阻塞页面的解析和渲染，使用外链加载js和css
  因为js和css文件可能会被浏览器进行缓存，而html文档通常不会配置为可缓存的，每次请求html文档会去请求js和css，如果文件内容不变的情况，使用外链可以加快文件的获取和减少请求文件的数量，
2. 使用防抖和节流，避免不必要的请求
3. 缓存一些js的计算结果

> 图片
1. 使用字体图标代替图片图标，图片图标会增加网络请求次数而iconfont不会添加而外的请求
2. 使用雪碧图，减少图片的请求次数
3. 对于一些简单的图标可以使用css3来实现，比如三角形图标
4. 使用webp格式代替jpg 和 png， webp格式的图片体积会更小

> 回流和重绘


> 垃圾回收
- 垃圾的产生：
  当代码创建一个基本类型，对象，函数等都是需要开辟内存的，但分配内存是引擎做的事，我们并不关心，
  但当创建出的对象不在被引用，那么javascript是如何发现并清理的？
  举个例子：
  ```js
    let test = { name: "zhangsan" };
    test = [1,2,3]
  ```
  javascript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，
  所以，javascript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。

  因此上面代码中 在堆内存中创建了一个 name为zhangsan的对象，在栈内存中创建test来执行堆内存中的对象，
  接下来又在堆中创建了一个 数组， 然后将test的引用指向了这个数组， 那么上面创建的对象就没有被引用，
  那么该对象就就会永远闲置在那边，系统的内存是有限，如果不释放闲置对象的内存，那么随着程序的运行，
  内存会被分配完，导致系统崩溃。因此就要及时的释放内存

  在javascript内存管理中有一个概念叫做：可达性
  就是以某种方式可以访问，或者说是会被用到的值，它们会被存储在内存中，如果不可访问的值，那么就说明需要被回收

  那么该如何回收呢？

  JavaScript垃圾回收机制会定期的找出那些不在被使用的值，然后释放其内存。
  
  那如何查找才更有效率呢？
  一般用两种算法来进行查找： 引用计数 和 标记清除 算法
  标记清除是最常用，标记清除法大致过程如下
  首先垃圾收集器会在运行时给内存中的 所有变量都添加上标记，刚开始都标记成0
  然后从根对象（根对象包括但不限于window对象 或 文档DOM树等）中开始进行遍历，把有用到的对象标记成 1
  遍历结束后就把标记为0 的对象进行销毁释放其内存
  最后把内存中的所有对象都标记成0 等待下一轮回收

  标记清除法的优缺点：
  优点： 实现简单
  缺点：清除之后，清除出来的内存空间是不连续的，会出现内存碎片，在下一次内存分配时候需要找到合适的块才能进行分配

  假如需要创建一个 数组，该数组的大小为 size
  内存分配有有三种分配策略：
  first-fit: 找到大于size的块就立即返回
  best-fit：遍历整个闲散空间，返回大于等于size的最小分块
  worst-fit：遍历整个闲散空间， 找到最大的内存块，将该内存块分为两段，一段为size，另一段为剩下的大小

  一般使用的是第一种分配方式
  第三种会照成内存碎片 不太推荐使用

  为解决标记清除法的缺点，内存碎片比较多，可用 标记整理算法 来标记不需要清理的对象，
  然后将不需要清理的对象向一边移动，最后清理掉边界内存
  

  引用计数法：它把 大象是否被需要 简化定义成 对象有没有被其他对象引用
  如果没有对象引用到它，那么它就会被回收
  引用计数的含义就是 当引用类型的值复制给一个变量后，那么值的引用次数就会 +1
  当该变量被赋予其他的值后，该引用类型的值的引用次数就会减少1，当引用次数为0的时候就会被垃圾回收机制回收

  但该算法有一个很大的缺点就是，如果出现循环引用的话，那么这两个循环引用的对象的引用次数就始终是2， 不会被垃圾回收机制回收
  这样就会造成大量的内存不会被释放，导致系统卡顿崩溃

  引用计数的优点：在对象引用时就可以进行计数，如果计数为0，可以立即进行垃圾回收
  而标记清除需要遍历内存中的所有对象，并对活动和非活动的对象进行标记，并且会定时暂停执行中的线程去进行垃圾回收

  
